name: Ivy Fuzzy Matching Tests
description: |
  Tests fuzzy matching rules with similarity thresholds:
  1. Create entity type with fuzzy match rule on name field
  2. Send entities with similar (but not exact) names
  3. Verify entities are staged and processed

setup:
  # Create entity type for fuzzy matching
  - http_request:
      service: ivy
      method: POST
      path: /api/v1/entity-types
      body:
        name: "Fuzzy Test Person"
        key: "fuzzyperson{{timestamp}}"
        description: "Person for fuzzy matching tests"
        schema:
          type: object
          properties:
            name:
              type: string
            email:
              type: string
            employee_id:
              type: string
          required:
            - name
      expect:
        status: 201
      save_as: entity_type

  # Create fuzzy match rule on name with 80% threshold
  - http_request:
      service: ivy
      method: POST
      path: /api/v1/match-rules
      body:
        entity_type: "{{entity_type.key}}"
        name: "Fuzzy Name Match"
        description: "Match by similar names"
        priority: 50
        is_active: true
        score_weight: 0.8
        conditions:
          - field: "name"
            match_type: "fuzzy"
            weight: 1.0
            required: true
            threshold: 0.8
      expect:
        status: 201
      save_as: fuzzy_rule

  # Also create exact email match rule for comparison
  - http_request:
      service: ivy
      method: POST
      path: /api/v1/match-rules
      body:
        entity_type: "{{entity_type.key}}"
        name: "Exact Email Match"
        description: "Match by exact email"
        priority: 100
        is_active: true
        score_weight: 1.0
        conditions:
          - field: "email"
            match_type: "exact"
            weight: 1.0
            required: true
            case_sensitive: false
      expect:
        status: 201
      save_as: email_rule

  # Get Kafka offsets
  - get_kafka_offset:
      topic: ivy.public.staged_entities
      save_as: staged_offset

  - get_kafka_offset:
      topic: ivy.public.merged_entities
      save_as: merged_offset

steps:
  # ============================================
  # Test 1: Send first entity with name "Jonathan Smith"
  # ============================================
  - publish_kafka:
      topic: mapped-data
      key: "fuzzy-1-{{uuid}}"
      headers:
        tenant_id: "{{test_tenant}}"
        content_type: "application/json"
      value:
        source:
          type: "orchid"
          tenant_id: "{{test_tenant}}"
          integration: "okta"
          key: "users_sync"
          config_id: "okta-fuzzy-{{uuid}}"
          execution_id: "okta-fuzzy-exec-{{uuid}}"
        tenant_id: "{{test_tenant}}"
        execution_id: "okta-fuzzy-exec-{{uuid}}"
        source_key: "users_sync"
        config_id: "okta-fuzzy-{{uuid}}"
        integration: "okta"
        timestamp: "2026-01-11T10:00:00Z"
        target_schema:
          type: "entity"
          entity_type: "{{entity_type.key}}"
        data:
          name: "Jonathan Smith"
          email: "jsmith.{{uuid}}@example.com"
          employee_id: "emp-1-{{uuid}}"
          source_id: "okta-fuzzy-1-{{uuid}}"

  - wait:
      duration: "8s"
      reason: "Wait for first entity to be processed and indexed"

  # Verify first entity was staged
  - assert_kafka_message:
      topic: ivy.public.staged_entities
      from_offset: "{{staged_offset}}"
      timeout: 30s
      filter:
        skip_tenant_header_filter: true
        field_contains: payload.after.entity_type
        contains_value: "{{entity_type.key}}"
      assertions:
        - field: payload.after.tenant_id
          equals: "{{test_tenant}}"
        - field: payload.op
          equals: "c"
      save_as: first_staged

  # Verify first entity created merged entity
  - assert_kafka_message:
      topic: ivy.public.merged_entities
      from_offset: "{{merged_offset}}"
      timeout: 30s
      filter:
        skip_tenant_header_filter: true
        field_contains: payload.after.entity_type
        contains_value: "{{entity_type.key}}"
      assertions:
        - field: payload.after.tenant_id
          equals: "{{test_tenant}}"
        - field: payload.op
          equals: "c"
      save_as: first_merged

  # ============================================
  # Test 2: Send second entity with similar name "John Smith"
  # This should potentially match via fuzzy rule
  # ============================================
  
  - get_kafka_offset:
      topic: ivy.public.merged_entities
      save_as: merged_offset_2

  - publish_kafka:
      topic: mapped-data
      key: "fuzzy-2-{{uuid}}"
      headers:
        tenant_id: "{{test_tenant}}"
        content_type: "application/json"
      value:
        source:
          type: "orchid"
          tenant_id: "{{test_tenant}}"
          integration: "workday"
          key: "users_sync"
          config_id: "wd-fuzzy-{{uuid}}"
          execution_id: "wd-fuzzy-exec-{{uuid}}"
        tenant_id: "{{test_tenant}}"
        execution_id: "wd-fuzzy-exec-{{uuid}}"
        source_key: "users_sync"
        config_id: "wd-fuzzy-{{uuid}}"
        integration: "workday"
        timestamp: "2026-01-11T10:01:00Z"
        target_schema:
          type: "entity"
          entity_type: "{{entity_type.key}}"
        data:
          name: "John Smith"
          email: "johnsmith.{{uuid}}@example.com"
          employee_id: "emp-2-{{uuid}}"
          source_id: "wd-fuzzy-2-{{uuid}}"

  - wait:
      duration: "8s"
      reason: "Wait for second entity and matching"

  # Verify second entity triggered a CDC event
  - assert_kafka_message:
      topic: ivy.public.merged_entities
      from_offset: "{{merged_offset_2}}"
      timeout: 30s
      filter:
        skip_tenant_header_filter: true
        field_contains: payload.after.entity_type
        contains_value: "{{entity_type.key}}"
      assertions:
        - field: payload.after.tenant_id
          equals: "{{test_tenant}}"
        # Could be 'c' (new entity) or 'u' (merged) depending on fuzzy match
        - field: payload.op
          not_empty: true
      save_as: second_merged

  # Verify both entities are processed
  - assert:
      variable: first_staged.payload.after.entity_type
      contains: "fuzzyperson"
      message: "First entity should be staged"

  - assert:
      variable: second_merged.payload.after.entity_type
      contains: "fuzzyperson"
      message: "Second entity should produce merged entity event"

cleanup:
  # Delete match rules
  - http_request:
      service: ivy
      method: DELETE
      path: /api/v1/match-rules/{{fuzzy_rule.id}}
      expect:
        status_one_of: [200, 204, 404]

  - http_request:
      service: ivy
      method: DELETE
      path: /api/v1/match-rules/{{email_rule.id}}
      expect:
        status_one_of: [200, 204, 404]

  # Delete entity type
  - http_request:
      service: ivy
      method: DELETE
      path: /api/v1/entity-types/{{entity_type.id}}
      expect:
        status_one_of: [200, 204, 404]
