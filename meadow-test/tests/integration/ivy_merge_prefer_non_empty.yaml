name: Ivy Merge Strategy Prefer Non-Empty Tests
description: |
  Tests the prefer_non_empty merge strategy:
  1. Create entity type with prefer_non_empty merge strategy
  2. Send entity from first source with some empty fields
  3. Send entity from second source with values for those fields
  4. Verify the merged entity prefers non-empty values

setup:
  # Create entity type with prefer_non_empty merge strategy
  - http_request:
      service: ivy
      method: POST
      path: /api/v1/entity-types
      body:
        name: "Prefer Non-Empty Person"
        key: "pneperson{{timestamp}}"
        description: "Person for prefer_non_empty merge strategy tests"
        schema:
          type: object
          properties:
            email:
              type: string
            first_name:
              type: string
              merge_strategy: prefer_non_empty
            last_name:
              type: string
              merge_strategy: prefer_non_empty
            phone:
              type: string
              merge_strategy: prefer_non_empty
          required:
            - email
      expect:
        status: 201
      save_as: entity_type

  # Create exact email match rule
  - http_request:
      service: ivy
      method: POST
      path: /api/v1/match-rules
      body:
        entity_type: "{{entity_type.key}}"
        name: "Exact Email Match"
        description: "Match by exact email"
        priority: 100
        is_active: true
        score_weight: 1.0
        conditions:
          - field: "email"
            match_type: "exact"
            weight: 1.0
            required: true
            case_sensitive: false
      expect:
        status: 201
      save_as: match_rule

  # Get Kafka offsets
  - get_kafka_offset:
      topic: ivy.public.staged_entities
      save_as: staged_offset

  - get_kafka_offset:
      topic: ivy.public.merged_entities
      save_as: merged_offset

steps:
  # ============================================
  # Step 1: Send first entity with SOME empty fields
  # ============================================
  - set_variable:
      name: test_email
      value: "pne.{{uuid}}@example.com"

  - publish_kafka:
      topic: mapped-data
      key: "pne-source1-{{uuid}}"
      headers:
        tenant_id: "{{test_tenant}}"
        content_type: "application/json"
      value:
        source:
          type: "orchid"
          tenant_id: "{{test_tenant}}"
          integration: "okta"
          key: "users_sync"
          config_id: "okta-pne-{{uuid}}"
          execution_id: "okta-pne-exec-{{uuid}}"
        tenant_id: "{{test_tenant}}"
        execution_id: "okta-pne-exec-{{uuid}}"
        source_key: "users_sync"
        config_id: "okta-pne-{{uuid}}"
        integration: "okta"
        timestamp: "2024-01-01T10:00:00Z"
        target_schema:
          type: "entity"
          entity_type: "{{entity_type.key}}"
        data:
          email: "{{test_email}}"
          first_name: "John"
          last_name: ""
          phone: ""
          source_id: "okta-pne-user-{{uuid}}"

  - wait:
      duration: "8s"
      reason: "Wait for first entity to be processed and indexed"

  # Verify first entity was staged
  - assert_kafka_message:
      topic: ivy.public.staged_entities
      from_offset: "{{staged_offset}}"
      timeout: 30s
      filter:
        skip_tenant_header_filter: true
        field_contains: payload.after.entity_type
        contains_value: "{{entity_type.key}}"
      assertions:
        - field: payload.after.tenant_id
          equals: "{{test_tenant}}"
        - field: payload.op
          equals: "c"
      save_as: first_staged

  # Verify first merged entity created
  - assert_kafka_message:
      topic: ivy.public.merged_entities
      from_offset: "{{merged_offset}}"
      timeout: 30s
      filter:
        skip_tenant_header_filter: true
        field_contains: payload.after.entity_type
        contains_value: "{{entity_type.key}}"
      assertions:
        - field: payload.after.tenant_id
          equals: "{{test_tenant}}"
        - field: payload.op
          equals: "c"
      save_as: first_merged

  # ============================================
  # Step 2: Send second entity with VALUES for empty fields
  # ============================================
  
  - get_kafka_offset:
      topic: ivy.public.merged_entities
      save_as: merged_offset_2

  - publish_kafka:
      topic: mapped-data
      key: "pne-source2-{{uuid}}"
      headers:
        tenant_id: "{{test_tenant}}"
        content_type: "application/json"
      value:
        source:
          type: "orchid"
          tenant_id: "{{test_tenant}}"
          integration: "workday"
          key: "users_sync"
          config_id: "wd-pne-{{uuid}}"
          execution_id: "wd-pne-exec-{{uuid}}"
        tenant_id: "{{test_tenant}}"
        execution_id: "wd-pne-exec-{{uuid}}"
        source_key: "users_sync"
        config_id: "wd-pne-{{uuid}}"
        integration: "workday"
        timestamp: "2024-01-02T10:00:00Z"
        target_schema:
          type: "entity"
          entity_type: "{{entity_type.key}}"
        data:
          email: "{{test_email}}"
          first_name: ""
          last_name: "Smith"
          phone: "555-1234"
          source_id: "wd-pne-user-{{uuid}}"

  - wait:
      duration: "8s"
      reason: "Wait for second entity and merging"

  # Verify merged entity was updated
  - assert_kafka_message:
      topic: ivy.public.merged_entities
      from_offset: "{{merged_offset_2}}"
      timeout: 30s
      filter:
        skip_tenant_header_filter: true
        field_contains: payload.after.entity_type
        contains_value: "{{entity_type.key}}"
      assertions:
        - field: payload.after.tenant_id
          equals: "{{test_tenant}}"
        - field: payload.op
          not_empty: true
      save_as: second_merged

  # Verify both entities processed
  - assert:
      variable: first_staged.payload.after.entity_type
      contains: "pneperson"
      message: "First entity should be staged"

  - assert:
      variable: second_merged.payload.after.entity_type
      contains: "pneperson"
      message: "Second entity should trigger merge"

cleanup:
  # Delete match rule
  - http_request:
      service: ivy
      method: DELETE
      path: /api/v1/match-rules/{{match_rule.id}}
      expect:
        status_one_of: [200, 204, 404]

  # Delete entity type
  - http_request:
      service: ivy
      method: DELETE
      path: /api/v1/entity-types/{{entity_type.id}}
      expect:
        status_one_of: [200, 204, 404]
